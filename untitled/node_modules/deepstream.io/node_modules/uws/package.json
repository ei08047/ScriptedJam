{
  "name": "uws",
  "version": "0.12.0",
  "scripts": {
    "install": "node-gyp rebuild > build_log.txt 2>&1 || exit 0"
  },
  "main": "uws.js",
  "description": "Highly scalable WebSocket server & client library",
  "engines": {
    "node": ">=4"
  },
  "keywords": [
    "websockets",
    "µWS",
    "µWebSockets",
    "uws",
    "microWS",
    "lightweight",
    "fast"
  ],
  "homepage": "https://github.com/uWebSockets/uWebSockets",
  "license": "Zlib",
  "author": {
    "name": "Alex Hultman",
    "email": "alexhultman@gmail.com",
    "url": "https://github.com/alexhultman"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/uWebSockets/uWebSockets.git"
  },
  "gitHead": "5a515f964d0032059045f3a5b455a45faa641bd8",
  "readme": "<div align=\"center\"><img src=\"images/logo.png\"/></div>\r\n`µWS` is one of the most lightweight, efficient & scalable WebSocket server implementations available. It features an easy-to-use, fully async object-oriented interface and scales to millions of connections using only a fraction of memory compared to the competition. While performance and scalability are two of our top priorities, we consider security, stability and standards compliance paramount. License is zlib/libpng (very permissive & suits commercial applications).\r\n\r\n* Autobahn tests [all pass](http://htmlpreview.github.io/?https://github.com/uWebSockets/uWebSockets/blob/master/autobahn/index.html).\r\n* Significantly outperforms `WebSocket++`, `libwebsockets`, `Beast`, `Crow`, `Kaazing Gateway`, `ws` and `Socket.IO` in every tested dimension (see benchmark table below).\r\n* Linux, OS X & Windows support.\r\n* Valgrind / AddressSanitizer clean.\r\n* Built-in load balancing and multi-core scalability.\r\n* SSL/TLS support & integrates with foreign HTTPS servers.\r\n* Permessage-deflate built-in.\r\n* Node.js binding exposed as the well-known `ws` interface (`uws` is at least 10x faster and 20x more scalable).\r\n\r\n[![npm version](https://badge.fury.io/js/uws.svg)](https://badge.fury.io/js/uws) [![](https://api.travis-ci.org/uWebSockets/uWebSockets.svg?branch=master)](https://travis-ci.org/uWebSockets/uWebSockets) [![](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/uWebSockets/uWebSockets)\r\n\r\n## Benchmarks table - [validate](https://github.com/alexhultman/uWebSockets/tree/master/benchmarks#websocket-echo-server-benchmarks)\r\nImplementation | User space memory scaling | Connection performance | Short message throughput | Huge message throughput\r\n--- | --- | --- | --- | ---\r\nBeast 1.0.0 b17 | µWS is **7x** as lightweight :+1: | µWS is **4x** as performant | µWS is **22x** as performant | µWS is **3x** as performant\r\nlibwebsockets 2.0 | µWS is **11x** as lightweight | µWS is **equal** in performance :+1: | µWS is **6x** as performant | µWS is **4x** as performant\r\nCrow [Sep 21] | µWS is **13x** as lightweight | µWS is **2x** as performant | µWS is **12x** as performant | unable to measure\r\nws v1.1.0 + binary addons | µWS is **47x** as lightweight | µWS is **18x** as performant | µWS is **33x** as performant | µWS is **2x** as performant\r\nKaazing Gateway Community 5.0.0 | µWS is **62x** as lightweight | µWS is **15x** as performant | µWS is **18x** as performant | unable to measure\r\nSocket.IO 1.5.1 | µWS is **62x** as lightweight | µWS is **42x** as performant :-1: | µWS is **61x** as performant :-1: | data missing\r\nWebSocket++ v0.7.0 | µWS is **63x** as lightweight :-1: | µWS is **4x** as performant | µWS is **3x** as performant :+1: | µWS is **2x** as performant :+1:\r\n\r\n*Benchmarks are run with default settings in all libraries, except for `ws` which is run with the native performance addons. These results were achieved with the native C++ server, not the Node.js addon. Expect worse performance and scalability when using Node.js (don't worry, the Node.js addon will run circles around `ws`).*\r\n\r\n## Built with µWS\r\n<div align=\"center\"><img src=\"images/builtwithuws.png\"/></div>\r\n\r\n## Usage\r\n\r\n### C++\r\n`µWebSockets` is a high performance C++ library with optional bindings to Node.js. It is greatly recommended investing in a proper C++ implementation if performance and memory scalability is considered critical for the solution in whole. The C++ interface has been designed for simplicity and only requires you to write a few lines of code to get a working server:\r\n\r\n```c++\r\n#include <uWS.h>\r\n\r\nint main()\r\n{\r\n    uWS::Hub h;\r\n\r\n    h.onMessage([](uWS::WebSocket<uWS::SERVER> ws, char *message, size_t length, uWS::OpCode opCode) {\r\n        ws.send(message, length, opCode);\r\n    });\r\n\r\n    h.listen(3000);\r\n    h.run();\r\n}\r\n```\r\n\r\n### Node.js\r\nWe built `µWS` with the existing Node.js infrastructure in mind. That's why we target the widespread `ws` interface, allowing us to seamlessly integrate with already existing projects. You simply swap `require('ws')` with `require('uws')`:\r\n\r\n```javascript\r\nvar WebSocketServer = require('uws').Server;\r\nvar wss = new WebSocketServer({ port: 3000 });\r\n\r\nfunction onMessage(message) {\r\n    console.log('received: ' + message);\r\n}\r\n\r\nwss.on('connection', function(ws) {\r\n    ws.on('message', onMessage);\r\n    ws.send('something');\r\n});\r\n```\r\n\r\n##### Deviations from ws\r\nThere are some important incompatibilities with `ws` though, we aim to be ~90% compatible but will never implement behavior that is deemed too inefficient:\r\n\r\n* Binary data is passed zero-copy as an `ArrayBuffer`. This means you need to copy it to keep it past the callback. It also means you need to convert it with `Buffer.from(message)` if you expect a `Node.js Buffer`.\r\n* `webSocket._socket` is not a `net.Socket`, it is just a getter function with very basic functionalities.\r\n* `webSocket._socket.remote...` might fail, you need to cache it at connection.\r\n* `webSocket` acts like an `EventEmitter` with one listener per event maximum.\r\n* `webSocket.upgradeReq` is only valid during execution of the connection handler. If you want to keep properties of the upgradeReq for the entire lifetime of the webSocket you better attach that specific property to the webSocket at connection.\r\n\r\n##### Consider these projects\r\n`µWS` is already the default engine in recent versions of [deepstream.io](http://deepstream.io/) and [SocketCluster](http://socketcluster.io).\r\n\r\n##### I would stay away from these projects\r\n\r\nYou can enable `uws` in **Socket.IO** using something like this:\r\n```javascript\r\nvar io = require('socket.io')(80);\r\nio.engine.ws = new (require('uws').Server)({\r\n    noServer: true,\r\n    perMessageDeflate: false\r\n});\r\n```\r\n\r\nYou can set 'uws' as transformer in **Primus**:\r\n```javascript\r\nvar primus = new Primus(server, { transformer: 'uws' });\r\n```\r\n\r\n## Installation\r\n### Node.js developers\r\n[![](https://nodei.co/npm/uws.png)](https://www.npmjs.com/package/uws)\r\n\r\n* Node.js 4.x, 5.x & 6.x supported (Windows version requires Node.js 6.4.0+)\r\n* Linux, Mac OS X & Windows supported\r\n* `gcc` >= 4.8.0 and `make` (or compatible) are required to build from source. This translates to Visual Studio >= 2015 on Windows and Clang >= 3.3 on macOS.\r\n\r\nOn installation, the module will be attempted to be build from source. If that fails, it will attempt to fall back to prebuilt modules which are provided for most platforms. If that fails too, `uws` will throw on `require`.\r\n\r\n### C++ developers\r\n#### Dependencies\r\nFirst of all you need to install the required dependencies. On Unix systems this is typically done via package managers, like [homebrew](http://brew.sh) in the case of OS X or `dnf` in the case of Fedora Linux. On Windows you need to search the web for pre-compiled binaries or simply compile the dependencies yourself.\r\n\r\n* libuv 1.3+\r\n* OpenSSL 1.0.x\r\n* zlib 1.x\r\n* CMake 3.x\r\n\r\n#### Compilation\r\nObviously you will need to clone this repo to get the sources. We use CMake as build system.\r\n\r\n* `git clone https://github.com/uWebSockets/uWebSockets.git && cd uWebSockets`\r\n* `cmake .`\r\n\r\nNow, on Unix systems it should work by simply running `make`. Run [sudo] `make install` as you wish.\r\n\r\n##### Windows, in all its glory\r\nIf you are running Windows you should now have a bunch of Visual Studio project files and one solution file. Open the solution file, now you need to make sure the header include paths and library paths are all set according to where you installed the dependencies. You might also need to change the names of the libraries being linked against, all according to the names of the installed library files. You know the drill.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/uWebSockets/uWebSockets/issues"
  },
  "_id": "uws@0.12.0",
  "_shasum": "bff99048cc7af0c119fd024c87f471c44368b24d",
  "_from": "git://github.com/deepstreamIO/uws-dependency.git#v0.12.0",
  "_resolved": "git://github.com/deepstreamIO/uws-dependency.git#5a515f964d0032059045f3a5b455a45faa641bd8",
  "_fromGithub": true
}
